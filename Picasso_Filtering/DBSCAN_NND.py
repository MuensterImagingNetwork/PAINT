#Created by Sarah Weischer
#20220805

########################################################################################################################
# Imports
import pandas as pd
from picasso import io
import seaborn as sns
import matplotlib.pyplot as plt
import os.path as _ospath
import numpy as np
from picasso import render
import matplotlib.pyplot as plt
from picasso import postprocess
import glob
import h5py as _h5py
import numpy as np
from scipy.spatial import distance

def make_dictionary():
    pass

def save_cluster_locs(file_to_save, file_to_save_info, save_path):
    # Create a new dictionary for the new info
    #file_to_save = file_to_save.to_records(index=False)
    new_info = {}
    new_info["Generated by"] = author_date
    new_info["DBSCAN_params"] = DBSCAN_3_params
    info.append(new_info)
    base, ext = _ospath.splitext(save_path)
    new_path = base + '_DBSCAN_3.hdf5'
    io.save_locs(new_path, file_to_save, file_to_save_info)
    print('{} locs saved to {}.'.format(len(file_to_save), new_path))

def save_clusters(file_to_save, save_path):
    base, ext = _ospath.splitext(save_path)
    new_path = base + '_DBSCAN_3_clusters.hdf5'
    clusters = _h5py.File(new_path, "w")
    dset = clusters.create_dataset("clusters", data=file_to_save)
    print('{} locs saved to {}.'.format(len(file_to_save), new_path))

def nneighbor(loc_path):
    base, ext = _ospath.splitext(loc_path)
    paths = glob.glob(base + "_DBSCAN_3_clusters.hdf5")

    if paths:
        for path in paths:
            print("Loading {} ...".format(path))
            with _h5py.File(path, "r") as locs_file:
                locs = locs_file["clusters"][...]
            clusters = np.rec.array(locs, dtype=locs.dtype)
            points = np.array(clusters[["com_x", "com_y"]].tolist())
            alldist = distance.cdist(points, points)
            alldist[alldist == 0] = float("inf")
            minvals = np.amin(alldist, axis=0)
            base, ext = _ospath.splitext(path)
            out_path = base + "_minval.txt"
            np.savetxt(out_path, minvals, newline="\r\n")
            print("Saved filest o: {}".format(out_path))

    return minvals

# Settings
sns.set_palette("Set1", 8, .75)
sns.set_style("ticks")

# Paramters/User input
# To Do: Make config file ?

# Variables
pixelsize = 160 # in nm
em = 580 # emission wavelength in nm
author_date = "SW_20220805"

# DBSCAN parameters
DBSCAN_3_params = (0.05, 20)

loc_path = r"D:\PROJECTS\MiN_Data\Workgroups\Sarah\Project_DNA-PAINT\Talin\20220727\Processed\Cell1\Analysis\P3_2h_588_80000001_locs_render_undrift_picked_RCC_DBSCAN_FILTER.hdf5"
save_path = r"D:\PROJECTS\MiN_Data\Workgroups\Sarah\Project_DNA-PAINT\Talin\20220727\Processed\Cell1\Analysis\P3_2h_588_80000001_locs_render_undrift_picked_RCC_DBSCAN_FILTER"

########################################################################################################################
# MAIN
base, ext = _ospath.splitext(loc_path)
# Load localizations
locs, info = io.load_locs(loc_path)
print('Loaded {} locs.'.format(len(locs)))

# Calculate median localization precision and NeNA
med_loc_prec = np.median(postprocess.localization_precision(locs.photons, locs.sx, locs.bg, em))
try:
    NeNA = postprocess.nena(locs, info)[1]
except ValueError:
    print("NeNA calculation not possible")
    NeNA = 0

print("Median localization precision:", med_loc_prec, "pixel, " , med_loc_prec * pixelsize,"nm.")
print("NeNA precision:", NeNA, "pixel, " , NeNA * pixelsize,"nm.")

# Perform DBSCAN
clusters_3, cluster_locs_3 = postprocess.dbscan(locs, radius=DBSCAN_3_params[0], min_density=DBSCAN_3_params[1])
df_clustered_3 = pd.DataFrame.from_records(cluster_locs_3)

print("Number of clusters:", len(df_clustered_3.group.unique()))
print("Average number of localizations per cluster:", (df_clustered_3.frame.groupby(df_clustered_3.group).count()).mean().round())

# Save results, incl. cluster characteristics
save_cluster_locs(cluster_locs_3, info, save_path)
save_clusters(clusters_3, save_path)

# Perform nearest neighbor:
minval = nneighbor(loc_path)

#Plot NND
sns.violinplot(y=minval)
sns.stripplot(y=minval, color="black")
plt.ylabel("NND (unit?)")
plt.savefig(base + "_NND.png")